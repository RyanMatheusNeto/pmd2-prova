{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/defineProperty\";\nimport _slicedToArray from \"@babel/runtime/helpers/slicedToArray\";\nfunction ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\nimport { useControlledState as $vhjCi$useControlledState, clamp as $vhjCi$clamp, snapValueToStep as $vhjCi$snapValueToStep } from \"@react-stately/utils\";\nimport { NumberFormatter as $vhjCi$NumberFormatter, NumberParser as $vhjCi$NumberParser } from \"@internationalized/number\";\nimport { useState as $vhjCi$useState, useMemo as $vhjCi$useMemo, useCallback as $vhjCi$useCallback } from \"react\";\nfunction $de67e98908f0c6ee$export$7f629e9dc1ecf37c(props) {\n  var minValue = props.minValue,\n    maxValue = props.maxValue,\n    step = props.step,\n    formatOptions = props.formatOptions,\n    value = props.value,\n    defaultValue = props.defaultValue,\n    onChange = props.onChange,\n    locale = props.locale,\n    isDisabled = props.isDisabled,\n    isReadOnly = props.isReadOnly;\n  var _ref = (0, $vhjCi$useControlledState)(value, isNaN(defaultValue) ? NaN : defaultValue, onChange),\n    _ref2 = _slicedToArray(_ref, 2),\n    numberValue = _ref2[0],\n    setNumberValue = _ref2[1];\n  var _ref3 = (0, $vhjCi$useState)(function () {\n      return isNaN(numberValue) ? \"\" : new (0, $vhjCi$NumberFormatter)(locale, formatOptions).format(numberValue);\n    }),\n    _ref4 = _slicedToArray(_ref3, 2),\n    inputValue = _ref4[0],\n    setInputValue = _ref4[1];\n  var numberParser = (0, $vhjCi$useMemo)(function () {\n    return new (0, $vhjCi$NumberParser)(locale, formatOptions);\n  }, [locale, formatOptions]);\n  var numberingSystem = (0, $vhjCi$useMemo)(function () {\n    return numberParser.getNumberingSystem(inputValue);\n  }, [numberParser, inputValue]);\n  var formatter = (0, $vhjCi$useMemo)(function () {\n    return new (0, $vhjCi$NumberFormatter)(locale, _objectSpread(_objectSpread({}, formatOptions), {}, {\n      numberingSystem: numberingSystem\n    }));\n  }, [locale, formatOptions, numberingSystem]);\n  var intlOptions = (0, $vhjCi$useMemo)(function () {\n    return formatter.resolvedOptions();\n  }, [formatter]);\n  var format = (0, $vhjCi$useCallback)(function (value) {\n    return isNaN(value) || value === null ? \"\" : formatter.format(value);\n  }, [formatter]);\n  var clampStep = !isNaN(step) ? step : 1;\n  if (intlOptions.style === \"percent\" && isNaN(step)) clampStep = 0.01;\n  var _ref5 = (0, $vhjCi$useState)(numberValue),\n    _ref6 = _slicedToArray(_ref5, 2),\n    prevValue = _ref6[0],\n    setPrevValue = _ref6[1];\n  var _ref7 = (0, $vhjCi$useState)(locale),\n    _ref8 = _slicedToArray(_ref7, 2),\n    prevLocale = _ref8[0],\n    setPrevLocale = _ref8[1];\n  var _ref9 = (0, $vhjCi$useState)(formatOptions),\n    _ref10 = _slicedToArray(_ref9, 2),\n    prevFormatOptions = _ref10[0],\n    setPrevFormatOptions = _ref10[1];\n  if (!Object.is(numberValue, prevValue) || locale !== prevLocale || formatOptions !== prevFormatOptions) {\n    setInputValue(format(numberValue));\n    setPrevValue(numberValue);\n    setPrevLocale(locale);\n    setPrevFormatOptions(formatOptions);\n  }\n  var parsedValue = (0, $vhjCi$useMemo)(function () {\n    return numberParser.parse(inputValue);\n  }, [numberParser, inputValue]);\n  var commit = function commit() {\n    if (!inputValue.length) {\n      setNumberValue(NaN);\n      setInputValue(value === undefined ? \"\" : format(numberValue));\n      return;\n    }\n    if (isNaN(parsedValue)) {\n      setInputValue(format(numberValue));\n      return;\n    }\n    var clampedValue;\n    if (isNaN(step)) clampedValue = (0, $vhjCi$clamp)(parsedValue, minValue, maxValue);else clampedValue = (0, $vhjCi$snapValueToStep)(parsedValue, minValue, maxValue, step);\n    clampedValue = numberParser.parse(format(clampedValue));\n    setNumberValue(clampedValue);\n    setInputValue(format(value === undefined ? clampedValue : numberValue));\n  };\n  var safeNextStep = function safeNextStep(operation, minMax) {\n    var prev = parsedValue;\n    if (isNaN(prev)) {\n      var newValue = isNaN(minMax) ? 0 : minMax;\n      return (0, $vhjCi$snapValueToStep)(newValue, minValue, maxValue, clampStep);\n    } else {\n      var _newValue = (0, $vhjCi$snapValueToStep)(prev, minValue, maxValue, clampStep);\n      if (operation === \"+\" && _newValue > prev || operation === \"-\" && _newValue < prev) return _newValue;\n      return (0, $vhjCi$snapValueToStep)($de67e98908f0c6ee$var$handleDecimalOperation(operation, prev, clampStep), minValue, maxValue, clampStep);\n    }\n  };\n  var increment = function increment() {\n    var newValue = safeNextStep(\"+\", minValue);\n    if (newValue === numberValue) setInputValue(format(newValue));\n    setNumberValue(newValue);\n  };\n  var decrement = function decrement() {\n    var newValue = safeNextStep(\"-\", maxValue);\n    if (newValue === numberValue) setInputValue(format(newValue));\n    setNumberValue(newValue);\n  };\n  var incrementToMax = function incrementToMax() {\n    if (maxValue != null) setNumberValue((0, $vhjCi$snapValueToStep)(maxValue, minValue, maxValue, clampStep));\n  };\n  var decrementToMin = function decrementToMin() {\n    if (minValue != null) setNumberValue(minValue);\n  };\n  var canIncrement = (0, $vhjCi$useMemo)(function () {\n    return !isDisabled && !isReadOnly && (isNaN(parsedValue) || isNaN(maxValue) || (0, $vhjCi$snapValueToStep)(parsedValue, minValue, maxValue, clampStep) > parsedValue || $de67e98908f0c6ee$var$handleDecimalOperation(\"+\", parsedValue, clampStep) <= maxValue);\n  }, [isDisabled, isReadOnly, minValue, maxValue, clampStep, parsedValue]);\n  var canDecrement = (0, $vhjCi$useMemo)(function () {\n    return !isDisabled && !isReadOnly && (isNaN(parsedValue) || isNaN(minValue) || (0, $vhjCi$snapValueToStep)(parsedValue, minValue, maxValue, clampStep) < parsedValue || $de67e98908f0c6ee$var$handleDecimalOperation(\"-\", parsedValue, clampStep) >= minValue);\n  }, [isDisabled, isReadOnly, minValue, maxValue, clampStep, parsedValue]);\n  var validate = function validate(value) {\n    return numberParser.isValidPartialNumber(value, minValue, maxValue);\n  };\n  return {\n    validate: validate,\n    increment: increment,\n    incrementToMax: incrementToMax,\n    decrement: decrement,\n    decrementToMin: decrementToMin,\n    canIncrement: canIncrement,\n    canDecrement: canDecrement,\n    minValue: minValue,\n    maxValue: maxValue,\n    numberValue: parsedValue,\n    setNumberValue: setNumberValue,\n    setInputValue: setInputValue,\n    inputValue: inputValue,\n    commit: commit\n  };\n}\nfunction $de67e98908f0c6ee$var$handleDecimalOperation(operator, value1, value2) {\n  var result = operator === \"+\" ? value1 + value2 : value1 - value2;\n  if (value1 % 1 !== 0 || value2 % 1 !== 0) {\n    var value1Decimal = value1.toString().split(\".\");\n    var value2Decimal = value2.toString().split(\".\");\n    var value1DecimalLength = value1Decimal[1] && value1Decimal[1].length || 0;\n    var value2DecimalLength = value2Decimal[1] && value2Decimal[1].length || 0;\n    var multiplier = Math.pow(10, Math.max(value1DecimalLength, value2DecimalLength));\n    value1 = Math.round(value1 * multiplier);\n    value2 = Math.round(value2 * multiplier);\n    result = operator === \"+\" ? value1 + value2 : value1 - value2;\n    result /= multiplier;\n  }\n  return result;\n}\nexport { $de67e98908f0c6ee$export$7f629e9dc1ecf37c as useNumberFieldState };","map":{"version":3,"names":["$de67e98908f0c6ee$export$7f629e9dc1ecf37c","props","minValue","maxValue","step","formatOptions","value","defaultValue","onChange","locale","isDisabled","isReadOnly","_ref","$vhjCi$useControlledState","isNaN","NaN","_ref2","_slicedToArray","numberValue","setNumberValue","_ref3","$vhjCi$useState","$vhjCi$NumberFormatter","format","_ref4","inputValue","setInputValue","numberParser","$vhjCi$useMemo","$vhjCi$NumberParser","numberingSystem","getNumberingSystem","formatter","_objectSpread","intlOptions","resolvedOptions","$vhjCi$useCallback","clampStep","style","_ref5","_ref6","prevValue","setPrevValue","_ref7","_ref8","prevLocale","setPrevLocale","_ref9","_ref10","prevFormatOptions","setPrevFormatOptions","Object","is","parsedValue","parse","commit","length","undefined","clampedValue","$vhjCi$clamp","$vhjCi$snapValueToStep","safeNextStep","operation","minMax","prev","newValue","$de67e98908f0c6ee$var$handleDecimalOperation","increment","decrement","incrementToMax","decrementToMin","canIncrement","canDecrement","validate","isValidPartialNumber","operator","value1","value2","result","value1Decimal","toString","split","value2Decimal","value1DecimalLength","value2DecimalLength","multiplier","Math","pow","max","round"],"sources":["C:\\Users\\ryann\\OneDrive\\Área de Trabalho\\pdm\\my-app\\node_modules\\@react-stately\\numberfield\\dist\\packages\\@react-stately\\numberfield\\src\\index.ts","C:\\Users\\ryann\\OneDrive\\Área de Trabalho\\pdm\\my-app\\node_modules\\@react-stately\\numberfield\\dist\\packages\\@react-stately\\numberfield\\src\\useNumberFieldState.ts"],"sourcesContent":["/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nexport {useNumberFieldState} from './useNumberFieldState';\n\nexport type {NumberFieldStateOptions} from './useNumberFieldState';\nexport type {NumberFieldState} from './useNumberFieldState';\n","/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {clamp, snapValueToStep, useControlledState} from '@react-stately/utils';\nimport {NumberFieldProps} from '@react-types/numberfield';\nimport {NumberFormatter, NumberParser} from '@internationalized/number';\nimport {useCallback, useMemo, useState} from 'react';\n\nexport interface NumberFieldState {\n  /**\n   * The current text value of the input. Updated as the user types,\n   * and formatted according to `formatOptions` on blur.\n   */\n  inputValue: string,\n  /**\n   * The currently parsed number value, or NaN if a valid number could not be parsed.\n   * Updated based on the `inputValue` as the user types.\n   */\n  numberValue: number,\n  /** The minimum value of the number field. */\n  minValue: number,\n  /** The maximum value of the number field. */\n  maxValue: number,\n  /** Whether the current value can be incremented according to the maximum value and step. */\n  canIncrement: boolean,\n  /** Whether the current value can be decremented according to the minimum value and step. */\n  canDecrement: boolean,\n  /**\n   * Validates a user input string according to the current locale and format options.\n   * Values can be partially entered, and may be valid even if they cannot currently be parsed to a number.\n   * Can be used to implement validation as a user types.\n   */\n  validate(value: string): boolean,\n  /** Sets the current text value of the input. */\n  setInputValue(val: string): void,\n  /** Sets the number value. */\n  setNumberValue(val: number): void,\n  /**\n   * Commits the current input value. The value is parsed to a number, clamped according\n   * to the minimum and maximum values of the field, and snapped to the nearest step value.\n   * This will fire the `onChange` prop with the new value, and if uncontrolled, update the `numberValue`.\n   * Typically this is called when the field is blurred.\n   */\n  commit(): void,\n  /** Increments the current input value to the next step boundary, and fires `onChange`. */\n  increment(): void,\n  /** Decrements the current input value to the next step boundary, and fires `onChange`. */\n  decrement(): void,\n  /** Sets the current value to the `maxValue` if any, and fires `onChange`. */\n  incrementToMax(): void,\n  /** Sets the current value to the `minValue` if any, and fires `onChange`. */\n  decrementToMin(): void\n}\n\nexport interface NumberFieldStateOptions extends NumberFieldProps {\n  /**\n   * The locale that should be used for parsing.\n   * @default 'en-US'\n   */\n  locale: string\n}\n\n/**\n * Provides state management for a number field component. Number fields allow users to enter a number,\n * and increment or decrement the value using stepper buttons.\n */\nexport function useNumberFieldState(\n  props: NumberFieldStateOptions\n): NumberFieldState {\n  let {\n    minValue,\n    maxValue,\n    step,\n    formatOptions,\n    value,\n    defaultValue,\n    onChange,\n    locale,\n    isDisabled,\n    isReadOnly\n  } = props;\n\n  let [numberValue, setNumberValue] = useControlledState<number>(value, isNaN(defaultValue) ? NaN : defaultValue, onChange);\n  let [inputValue, setInputValue] = useState(() => isNaN(numberValue) ? '' : new NumberFormatter(locale, formatOptions).format(numberValue));\n\n  let numberParser = useMemo(() => new NumberParser(locale, formatOptions), [locale, formatOptions]);\n  let numberingSystem = useMemo(() => numberParser.getNumberingSystem(inputValue), [numberParser, inputValue]);\n  let formatter = useMemo(() => new NumberFormatter(locale, {...formatOptions, numberingSystem}), [locale, formatOptions, numberingSystem]);\n  let intlOptions = useMemo(() => formatter.resolvedOptions(), [formatter]);\n  let format = useCallback((value: number) => (isNaN(value) || value === null) ? '' : formatter.format(value), [formatter]);\n\n  let clampStep = !isNaN(step) ? step : 1;\n  if (intlOptions.style === 'percent' && isNaN(step)) {\n    clampStep = 0.01;\n  }\n\n  // Update the input value when the number value or format options change. This is done\n  // in a useEffect so that the controlled behavior is correct and we only update the\n  // textfield after prop changes.\n  let [prevValue, setPrevValue] = useState(numberValue);\n  let [prevLocale, setPrevLocale] = useState(locale);\n  let [prevFormatOptions, setPrevFormatOptions] = useState(formatOptions);\n  if (!Object.is(numberValue, prevValue) || locale !== prevLocale || formatOptions !== prevFormatOptions) {\n    setInputValue(format(numberValue));\n    setPrevValue(numberValue);\n    setPrevLocale(locale);\n    setPrevFormatOptions(formatOptions);\n  }\n\n  let parsedValue = useMemo(() => numberParser.parse(inputValue), [numberParser, inputValue]);\n  let commit = () => {\n    // Set to empty state if input value is empty\n    if (!inputValue.length) {\n      setNumberValue(NaN);\n      setInputValue(value === undefined ? '' : format(numberValue));\n      return;\n    }\n\n    // if it failed to parse, then reset input to formatted version of current number\n    if (isNaN(parsedValue)) {\n      setInputValue(format(numberValue));\n      return;\n    }\n\n    // Clamp to min and max, round to the nearest step, and round to specified number of digits\n    let clampedValue: number;\n    if (isNaN(step)) {\n      clampedValue = clamp(parsedValue, minValue, maxValue);\n    } else {\n      clampedValue = snapValueToStep(parsedValue, minValue, maxValue, step);\n    }\n\n    clampedValue = numberParser.parse(format(clampedValue));\n    setNumberValue(clampedValue);\n\n    // in a controlled state, the numberValue won't change, so we won't go back to our old input without help\n    setInputValue(format(value === undefined ? clampedValue : numberValue));\n  };\n\n  let safeNextStep = (operation: '+' | '-', minMax: number) => {\n    let prev = parsedValue;\n\n    if (isNaN(prev)) {\n      // if the input is empty, start from the min/max value when incrementing/decrementing,\n      // or zero if there is no min/max value defined.\n      let newValue = isNaN(minMax) ? 0 : minMax;\n      return snapValueToStep(newValue, minValue, maxValue, clampStep);\n    } else {\n      // otherwise, first snap the current value to the nearest step. if it moves in the direction\n      // we're going, use that value, otherwise add the step and snap that value.\n      let newValue = snapValueToStep(prev, minValue, maxValue, clampStep);\n      if ((operation === '+' && newValue > prev) || (operation === '-' && newValue < prev)) {\n        return newValue;\n      }\n\n      return snapValueToStep(\n        handleDecimalOperation(operation, prev, clampStep),\n        minValue,\n        maxValue,\n        clampStep\n      );\n    }\n  };\n\n  let increment = () => {\n    let newValue = safeNextStep('+', minValue);\n\n    // if we've arrived at the same value that was previously in the state, the\n    // input value should be updated to match\n    // ex type 4, press increment, highlight the number in the input, type 4 again, press increment\n    // you'd be at 5, then incrementing to 5 again, so no re-render would happen and 4 would be left in the input\n    if (newValue === numberValue) {\n      setInputValue(format(newValue));\n    }\n\n    setNumberValue(newValue);\n  };\n\n  let decrement = () => {\n    let newValue = safeNextStep('-', maxValue);\n\n    if (newValue === numberValue) {\n      setInputValue(format(newValue));\n    }\n\n    setNumberValue(newValue);\n  };\n\n  let incrementToMax = () => {\n    if (maxValue != null) {\n      setNumberValue(snapValueToStep(maxValue, minValue, maxValue, clampStep));\n    }\n  };\n\n  let decrementToMin = () => {\n    if (minValue != null) {\n      setNumberValue(minValue);\n    }\n  };\n\n  let canIncrement = useMemo(() => (\n    !isDisabled &&\n    !isReadOnly &&\n    (\n      isNaN(parsedValue) ||\n      isNaN(maxValue) ||\n      snapValueToStep(parsedValue, minValue, maxValue, clampStep) > parsedValue ||\n      handleDecimalOperation('+', parsedValue, clampStep) <= maxValue\n    )\n  ), [isDisabled, isReadOnly, minValue, maxValue, clampStep, parsedValue]);\n\n  let canDecrement = useMemo(() => (\n    !isDisabled &&\n    !isReadOnly &&\n    (\n      isNaN(parsedValue) ||\n      isNaN(minValue) ||\n      snapValueToStep(parsedValue, minValue, maxValue, clampStep) < parsedValue ||\n      handleDecimalOperation('-', parsedValue, clampStep) >= minValue\n    )\n  ), [isDisabled, isReadOnly, minValue, maxValue, clampStep, parsedValue]);\n\n  let validate = (value: string) => numberParser.isValidPartialNumber(value, minValue, maxValue);\n\n  return {\n    validate,\n    increment,\n    incrementToMax,\n    decrement,\n    decrementToMin,\n    canIncrement,\n    canDecrement,\n    minValue,\n    maxValue,\n    numberValue: parsedValue,\n    setNumberValue,\n    setInputValue,\n    inputValue,\n    commit\n  };\n}\n\nfunction handleDecimalOperation(operator: '-' | '+', value1: number, value2: number): number {\n  let result = operator === '+' ? value1 + value2 : value1 - value2;\n\n  // Check if we have decimals\n  if (value1 % 1 !== 0 || value2 % 1 !== 0) {\n    const value1Decimal = value1.toString().split('.');\n    const value2Decimal = value2.toString().split('.');\n    const value1DecimalLength = (value1Decimal[1] && value1Decimal[1].length) || 0;\n    const value2DecimalLength = (value2Decimal[1] && value2Decimal[1].length) || 0;\n    const multiplier = Math.pow(10, Math.max(value1DecimalLength, value2DecimalLength));\n\n    // Transform the decimals to integers based on the precision\n    value1 = Math.round(value1 * multiplier);\n    value2 = Math.round(value2 * multiplier);\n\n    // Perform the operation on integers values to make sure we don't get a fancy decimal value\n    result = operator === '+' ? value1 + value2 : value1 - value2;\n\n    // Transform the integer result back to decimal\n    result /= multiplier;\n  }\n\n  return result;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}